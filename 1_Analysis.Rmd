---
title: "1_Analysis"
output: html_document
date: "2022-11-03"
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

# Load all data

## Load Libraries

```{r, warning = FALSE}
library(ggsci)
library(tidyverse)
library(dplyr)
library(forcats)
library(reshape2)
library(stringr)
library(tidyr)
library(tibble)
library(sangerseqR)
library(DECIPHER)
library(Biostrings)
library(phangorn)
library(ape)
library(ggplot2)
library(ggtree)
library(patchwork)
library(bioseq)
library(kmer)
library(GUniFrac)
library(seqinr)
library(vegan)
library(corrplot)
library(ggrepel)

library(ggmsa)
library(dendextend)
library(usedist)
```


## Load Symbiont Data
```{r, show_col_types = FALSE}
#here is the raw SymPortal Data output that contains data for ITS2 type profiles and DIVs associated with all three coral species
seqs <- read_tsv("20210612_marzonie/186_20211115_03_DBV_20211116T024440.seqs.absolute.abund_and_meta.txt") %>%
  mutate(plate = case_when(str_detect(sample_name, "Plate1") ~ "Plate1",
                           str_detect(sample_name, "Plate2") ~ "Plate2",
                           str_detect(sample_name, "Plate3") ~ "Plate3",
                           str_detect(sample_name, "Plate4") ~ "Plate4",
                           str_detect(sample_name, "Plate5") ~ "Plate5", 
                           str_detect(sample_name, "Plate6") ~ "Plate6", 
                           str_detect(sample_name, "Plate7") ~ "Plate7", 
                           TRUE ~ "Other"),
         position = str_sub(sample_name, start = 8, end = 11),
         plate_position = paste0(plate, "_", position)) %>%
  filter(!(is.na(sample_name))) %>%
  select(sample_name = plate_position, `A1`:`1275234_G`) %>%
  mutate(sample_name = as.factor(sample_name))
```

## Load Metadata
```{r}
meta = read.csv("Metadata.csv") %>% 
  mutate(sample_name = as.factor(sample_name))
```


## Load Custom Functions
```{r}
read_fasta_df <- function (file = "") {
  fasta <- readLines(file)
  ind <- grep(">", fasta)
  s <- data.frame(ind = ind, from = ind + 1, to = c((ind - 
    1)[-1], length(fasta)))
  seqs <- rep(NA, length(ind))
  for (i in 1:length(ind)) {
    seqs[i] <- paste(fasta[s$from[i]:s$to[i]], collapse = "")
  }
  tib <- tibble(label = gsub(">", "", fasta[ind]), sequence = seqs)
  return(tib)
}

write_fasta_df <- function (data, filename) 
{
    fastaLines = c()
    for (rowNum in 1:nrow(data)) {
        fastaLines = c(fastaLines, as.character(paste(">", 
            data[rowNum, "label"], sep = "")))
        fastaLines = c(fastaLines, as.character(data[rowNum, 
            "sequence"]))
    }
    fileConn <- file(filename)
    writeLines(fastaLines, fileConn)
    close(fileConn)
}

dna_to_DNAbin <- function (dna){
  DNAbin <- as_DNAbin(dna)
  names(DNAbin) <- names(dna)
  return(DNAbin)
}
dna_to_DNAStringset <- function(x) 
{
    bioseq:::check_dna(x)
    DNAstr <- DNAStringSet(paste(x))
    names(DNAstr) <- names(x)
    return(DNAstr)
}

DNAStringSet_to_dna <- function(x){
    x_dna <- as_dna(paste(x))
    names(x_dna) <- names(x)
    res <- tibble(label = names(x), sequence = x_dna)
    return(res)
}

# Convert DNAstringset to DNAbin
DNAStringSet_to_DNAbin <- function(DNAStringSet){
  DNAbin <- as.DNAbin(DNAStringSet)
  return(DNAbin)
}

# https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2315-y
palette <- c("A" = "#46ff2d", 
             "G" = "#ffae01", 
             "C" = "#f24641", 
             "T" = "#4294fa", 
             "K" = "#8b4816",
             "M" = "#83831f",
             "R" = "#ffff81",
             "S" = "#ff9d80",
             "Y" = "#e381f2",
             "W" = "#80fff2",
             "V" = "#fde4b8",
             "B" = "#f9c1bf",
             "H" = "#c0d9f9",
             "D" = "#c7ffba",
             "U" = "#8989fb",
             "N" = "black", 
             "-" = "white",
             "+" = "White")


pal_df <- data.frame(names = names(palette), col = palette)
```


## Combining sequence/metadata 
```{r}
# Convert to long format
seqs_long <- seqs %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`1275234_G`) %>%
  pivot_longer(`A1`:`1275234_G`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check <- seqs_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check %>%
  filter(total > 1500)

#we filter out 3 samples with less than 1500 reads: Plate4_B007, Plate5_G011, Plate7_D009

# Filter out the failed samples
seqs_long <- seqs_long %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Create a random palette for each sequence
n <- length(levels(seqs_long$name))
seqs_pal = rainbow(n, s=.6, v=.9)[sample(1:n,n, replace = FALSE)]
names(seqs_pal) <- levels(seqs_long$name)

# Read in the profile data
profiles_raw <- read_tsv("20210612_marzonie/186_20211115_03_DBV_20211116T024440.profiles.absolute.abund_and_meta.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1/A1h`:`C42a/C1-C42.2`) %>%
   mutate(plate = case_when(str_detect(sample_name, "Plate1") ~ "Plate1",
                           str_detect(sample_name, "Plate2") ~ "Plate2",
                           str_detect(sample_name, "Plate3") ~ "Plate3",
                           str_detect(sample_name, "Plate4") ~ "Plate4",
                           str_detect(sample_name, "Plate5") ~ "Plate5", 
                           str_detect(sample_name, "Plate6") ~ "Plate6", 
                           str_detect(sample_name, "Plate7") ~ "Plate7", 
                           TRUE ~ "Other"),
         position = str_sub(sample_name, start = 8, end = 11),
         plate_position = paste0(plate, "_", position)) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name = plate_position, -plate, -position, `A1/A1h`:`C42a/C1-C42.2`)

#Convert to long format 
profiles_long <- profiles_raw %>%
  pivot_longer(`A1/A1h`:`C42a/C1-C42.2`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum <- profiles_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual <- left_join(profiles_sum, san_check, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data <- rbind(profiles_long, residual) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 

# Create palette for profiles (this is a darker palette)
n <- length(levels(profile_data$name))
profile_pal = rainbow(n, s=.6, v=.6)[sample(1:n,n, replace = FALSE)]
names(profile_pal) <- levels(profile_data$name)

# Merge the palettes and replace the non-profile sequences with grey
all_pal <- c(seqs_pal, profile_pal)
all_pal['non-profile sequences'] <- "#808080" 

# Join profiles and sequence data together into single dataframe and add more metadata
all_data <- rbind(seqs_long, profile_data) %>%
  mutate(coral_genus = case_when(str_detect(mtORF, "mean|verru|aplo|nkno") ~ "Pocillopora",
                                 str_detect(mtORF, "humil") ~ "Acropora",
                                 TRUE ~ "check"))

all_data %>% filter(coral_genus != "Acropora") %>% distinct(sample_name)
```

# 3.1 Library Stats

##Basic Stats
```{r}
# How many samples per species?
all_data %>%
  distinct(sample_name, mtORF) %>%
  group_by(mtORF) %>% 
  summarise(total_samples = n())

# Ahumilis	260			
# Haplotype8a	39			
# Pmeandrina	133			
# Pverrucosa	152			
# Unknown	22

humil_total <- 260
hap8a_total <- 39
veru_total <- 152
mean_total <- 133

#remove unknowns from downstream analysis
clean_data <- all_data %>%
  filter(mtORF != "Unknown")

# Total number of sequences (for whole library)? 
study_total <- clean_data %>% 
   filter(!(str_detect(name, "p_")),
         name != "non-profile sequences") %>% 
  summarise(total_seqs = sum(value)) %>%
  pull(total_seqs)
#15,336,586 total 	

#Total number of sequences (per species)? 
clean_data %>%
    filter(!(str_detect(name, "p_")),
         name != "non-profile sequences") %>% 
  group_by(mtORF) %>%
  summarise(total_seqs = sum(value))

# Ahumilis	6627245			
# Haplotype8a	1025443			
# Pmeandrina	3512508			
# Pverrucosa	4171390	
```


## Sequencing Depth
```{r}
# Average per sample sequencing depth? (per coral host genus, and per coral species)

# Average per sample across all spp
clean_data %>%
  group_by(sample_name) %>% 
  dplyr::summarise(per_sample = sum(value)) %>%
  dplyr::summarise(mean_all = mean(per_sample))
# Across all:  52522.55	

#average per sample per coral host genus 
clean_data %>%
  group_by(coral_genus, sample_name) %>% 
  summarise(per_sample = sum(value)) %>%
  summarise(mean_all = mean(per_sample), n = n())
# Acropora	50978.81	260		
# Pocillopora	53761.36	324	


#average per sample per coral host species 
clean_data %>% 
  group_by(mtORF, sample_name) %>% 
  summarise(per_sample = sum(value)) %>%
  summarise(mean_all = mean(per_sample), n = n())
# Species
# Ahumilis	50978.81	260		
# Haplotype8a	52586.82	39		
# Pmeandrina	52819.67	133		
# Pverrucosa	54886.71	152		
```

##Number of sequences per symbiont genus 

```{r}
# Total number of Cladocopium 
clean_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "C" | str_detect(name, "_C")) %>% 
  summarise(sum = sum(value))
# 15335016	

(15335016 / study_total) * 100 # 99.98976 Clado

#Total number of Symbiodinium
clean_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "A" | str_detect(name, "_A")) %>% 
  summarise(sum = sum(value)) 
# 1552	total seqs
(1552 / study_total) * 100 # 0.01011959 Symbio


# Total number of Durusdinium sequences
clean_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "D" | str_detect(name, "_D")) %>% 
  summarise(sum = sum(value)) 
# 13 total reads

(13 / study_total) * 100 # 8.476463e-05 Durusdinium

```

## Characteristics of symbiont DIVs and Type Profiles 

```{r}
# general statements that apply to both species 

# what proportion of each sample are composed of non-profile sequences (grouped by coral host species)
clean_data %>%
  filter(str_detect(name, "non")) %>%
  group_by(mtORF) %>%
  summarise(mean = mean(value_rel))

# Ahumilis	0.2454587			
# Haplotype8a	0.1763951			
# Pmeandrina	0.1792804			
# Pverrucosa	0.1393484	

# TO DO FURTHER DOWN - humilis split, one side of the unifrac tree has a greater prop of non-profile seqs than the other

clean_data %>%
  filter(str_detect(name, "non")) %>%
  group_by(coral_genus) %>%
  summarise(mean = mean(value_rel))

# Acropora	0.2454587			
# Pocillopora	0.1601996	

# Acropora has a lot more non-profile sequences than any Pocillopora. 
```


## Total number of Type Profiles 

```{r}
library(tidyverse)

#total type profiles across Pocilloporidae 
clean_data %>%
  filter(coral_genus == "Pocillopora") %>% 
  filter(str_detect(name, "p_")) %>%    #profiles start with p_
  group_by(name) %>%
  dplyr:: count() %>%
  dplyr:: arrange(desc(n)) %>%
  ungroup() %>%
  mutate(prop = n/sum(n)) %>%
  mutate(cumulative_sum = cumsum(prop))

# profile n_samps prop_samps cumulative_sum
# p_C1/C42.2/C42g/C42a-C1b-C1au-C1az-C42h-C3	97	0.295731707	0.2957317	
# p_C1d/C1/C42.2/C3-C1b-C3cg-C115k-C45c-C1au-C41p	71	0.216463415	0.5121951	
# p_C1/C42.2/C42u-C1b-C42a-C1au-C115l-C1az-C115d	43	0.131097561	0.6432927	
# p_C1d/C1/C42.2-C3cg-C1b-C45c-C115k-C1au	36	0.109756098	0.7530488	
# p_C1d/C1/C1ba-C42.2-C3cg-C1b-C115k	13	0.039634146	0.7926829	
# p_C42u/C42a/C1/C42.2/C42b-C1b-C1au	11	0.033536585	0.8262195	
# p_C42.2/C1dh/C1/C1d-C1b-C3cg	9	0.027439024	0.8536585	
# p_C42.2/C1/C42a/C1b-C1au-C1az-C3-C115d	6	0.018292683	0.8719512	
# p_C1ag/C1/C1ah-C42.2-C3cg-C1b	6	0.018292683	0.8902439	
# p_C42g/C42a/C42.2/C1-C42h-C42b-C1b-C1au	5	0.015243902	0.9054878	
# p_C1d-C42.2-C1-C1k-C1b-C3cg	5	0.015243902	0.9207317	
# p_C42.2/C1/C42a-C1b-C42g-C42b-C1au-C1az	5	0.015243902	0.9359756	
# p_C1ag/C1/C42.2-C3cg-C1b-C1bi	4	0.012195122	0.9481707	
# p_C1ag-C1-C42.2-C1bi-C3cg-C1b-C1bk	2	0.006097561	0.9542683	
# p_C1d/C15h-C1-C42.2	2	0.006097561	0.9603659	
# p_C42u-C1-C42.2-C42a-C1b-C1au-C115k-C115d	2	0.006097561	0.9664634	
# p_C1ag/C1/C42.2/C1bi-C3cg-C1b-C3cw-C45c	2	0.006097561	0.9725610	
# p_C3-C3k	1	0.003048780	0.9756098	
# p_C42g-C42.2-C1-C1b-C42h-C42a-C42ba-C42b	1	0.003048780	0.9786585	
# p_C42a/C1/C42.2/C1b/C1j-C1au-C3-C115l	1	0.003048780	0.9817073	
# p_A1/A1h	1	0.003048780	0.9847561	
# p_C15h	1	0.003048780	0.9878049	
# p_C1ag/C1-C42.2-C3cg-C1b	1	0.003048780	0.9908537	
# p_C1d	1	0.003048780	0.9939024	
# p_C1ag/C1-C1m-C42.2-C1lr-C1bi-C3cg	1	0.003048780	0.9969512	
# p_C1/C42.2/C42g/C42a-C1b-C1az-C3-C1au	1	0.003048780	1.0000000	

#total number of profiles, in order of highest abundance across P. verrucosa samples 
clean_data %>%
  filter(mtORF == "Pverrucosa") %>% 
  filter(str_detect(name, "p_")) %>%    #profiles start with p_
  group_by(name) %>%
  dplyr:: count() %>%
  dplyr:: arrange(desc(n)) %>%
  ungroup() %>%
  mutate(prop = n/sum(n)) %>%
  mutate(cumulative_sum = cumsum(prop))

verru_pros <- 22

# p_C1d/C1/C42.2/C3-C1b-C3cg-C115k-C45c-C1au-C41p	71	0.461038961	0.4610390	
# p_C1d/C1/C42.2-C3cg-C1b-C45c-C115k-C1au	36	0.233766234	0.6948052	
# p_C1d/C1/C1ba-C42.2-C3cg-C1b-C115k	13	0.084415584	0.7792208	
# p_C42.2/C1dh/C1/C1d-C1b-C3cg	8	0.051948052	0.8311688	
# p_C1ag/C1/C1ah-C42.2-C3cg-C1b	6	0.038961039	0.8701299	
# p_C1d-C42.2-C1-C1k-C1b-C3cg	5	0.032467532	0.9025974	
# p_C1ag/C1/C42.2-C3cg-C1b-C1bi	4	0.025974026	0.9285714	
# p_C1ag-C1-C42.2-C1bi-C3cg-C1b-C1bk	2	0.012987013	0.9415584	
# p_C1d/C15h-C1-C42.2	2	0.012987013	0.9545455	
# p_C1/C42.2/C42g/C42a-C1b-C1au-C1az-C42h-C3	1	0.006493506	0.9610390	
# p_C1/C42.2/C42u-C1b-C42a-C1au-C115l-C1az-C115d	1	0.006493506	0.9675325	
# p_C3-C3k	1	0.006493506	0.9740260	
# p_C1ag/C1-C42.2-C3cg-C1b	1	0.006493506	0.9805195	
# p_C1d	1	0.006493506	0.9870130	
# p_C1ag/C1/C42.2/C1bi-C3cg-C1b-C3cw-C45c	1	0.006493506	0.9935065	
# p_C1ag/C1-C1m-C42.2-C1lr-C1bi-C3cg	1	0.006493506	1.0000000	

clean_data %>%
  filter(mtORF == "Pmeandrina") %>% 
  filter(str_detect(name, "p_")) %>%
  group_by(name) %>%
  dplyr:: count() %>%
  dplyr:: arrange(desc(n)) %>%
  ungroup() %>%
  mutate(prop = n/sum(n)) %>%
  mutate(cumulative_sum = cumsum(prop))

mean_pros <- 12

# p_C1/C42.2/C42g/C42a-C1b-C1au-C1az-C42h-C3	74	0.548148148	0.5481481	
# p_C1/C42.2/C42u-C1b-C42a-C1au-C115l-C1az-C115d	33	0.244444444	0.7925926	
# p_C42u/C42a/C1/C42.2/C42b-C1b-C1au	9	0.066666667	0.8592593	
# p_C42.2/C1/C42a/C1b-C1au-C1az-C3-C115d	5	0.037037037	0.8962963	
# p_C42.2/C1/C42a-C1b-C42g-C42b-C1au-C1az	5	0.037037037	0.9333333	
# p_C42g/C42a/C42.2/C1-C42h-C42b-C1b-C1au	3	0.022222222	0.9555556	
# p_C42g-C42.2-C1-C1b-C42h-C42a-C42ba-C42b	1	0.007407407	0.9629630	
# p_C42a/C1/C42.2/C1b/C1j-C1au-C3-C115l	1	0.007407407	0.9703704	
# p_A1/A1h	1	0.007407407	0.9777778	
# p_C15h	1	0.007407407	0.9851852	
# p_C42.2/C1dh/C1/C1d-C1b-C3cg	1	0.007407407	0.9925926	
# p_C1ag/C1/C42.2/C1bi-C3cg-C1b-C3cw-C45c	1	0.007407407	1.0000000	

clean_data %>%
  filter(mtORF == "Haplotype8a") %>% 
  filter(str_detect(name, "p_")) %>%    #profiles start with p_
  group_by(name) %>%
  dplyr:: count() %>%
  dplyr:: arrange(desc(n)) %>%
  ungroup() %>%
  mutate(prop = n/sum(n)) %>%
  mutate(cumulative_sum = cumsum(prop))

hap8a_pros <- 7

# p_C1/C42.2/C42g/C42a-C1b-C1au-C1az-C42h-C3	22	0.56410256	0.5641026	
# p_C1/C42.2/C42u-C1b-C42a-C1au-C115l-C1az-C115d	9	0.23076923	0.7948718	
# p_C42u/C42a/C1/C42.2/C42b-C1b-C1au	2	0.05128205	0.8461538	
# p_C42g/C42a/C42.2/C1-C42h-C42b-C1b-C1au	2	0.05128205	0.8974359	
# p_C42u-C1-C42.2-C42a-C1b-C1au-C115k-C115d	2	0.05128205	0.9487179	
# p_C42.2/C1/C42a/C1b-C1au-C1az-C3-C115d	1	0.02564103	0.9743590	
# p_C1/C42.2/C42g/C42a-C1b-C1az-C3-C1au	1	0.02564103	1.0000000	

clean_data %>%
  filter(mtORF == "Ahumilis") %>% 
  filter(str_detect(name, "p_")) %>%    #profiles start with p_
  group_by(name) %>%
  dplyr:: count() %>%
  dplyr:: arrange(desc(n)) %>%
  ungroup() %>%
  mutate(prop = n/sum(n)) %>%
  mutate(cumulative_sum = cumsum(prop))

humil_pros <- 23

# p_C3k/C3-C50a-C29-C21ab-C3b	160	0.592592593	0.5925926	
# p_C3k/C3-C50a-C21ab-C50f-C3ba-C3dq	52	0.192592593	0.7851852	
# p_C3k/C3-C50a-C3ba-C50f-C3dq-C21-C3a	14	0.051851852	0.8370370	
# p_C3k/C3-C50a-C3jv-C3vx-C3vy	12	0.044444444	0.8814815	
# p_C3bo/C3k-C3-C3bp-C50a-C29	6	0.022222222	0.9037037	
# p_C3k/C3/C1-C50a-C21ab	4	0.014814815	0.9185185	
# p_C3k-C3-C50a-C21ab-C3b	3	0.011111111	0.9296296	
# p_C3k-C3-C50a-C21ab-C50f-C3ba	2	0.007407407	0.9370370	
# p_C1/C42.2	2	0.007407407	0.9444444	
# p_C1/C1c	2	0.007407407	0.9518519	
# p_C1/C42.2/C42g/C42a-C1b-C1au-C1az-C42h-C3	1	0.003703704	0.9555556	
# p_A1	1	0.003703704	0.9592593	
# p_C3/C3k-C29-C21ab-C3b-C3gj-C21.12	1	0.003703704	0.9629630	
# p_C3-C21-C3k-C3at-C3b-C3av-C3dp	1	0.003703704	0.9666667	
# p_C40/C1-C3-C115	1	0.003703704	0.9703704	
# p_C42.2/C42a/C1-C1b	1	0.003703704	0.9740741	
# p_C1d/C1	1	0.003703704	0.9777778	
# p_C1/C3k-C1b-C3-C42.2-C1bh-C1br	1	0.003703704	0.9814815	
# p_C3/C21/C3av-C3at-C3b-C3dp	1	0.003703704	0.9851852	
# p_C3k-C50a-C3cz	1	0.003703704	0.9888889	
# p_C42a/C1-C42.2	1	0.003703704	0.9925926	
# p_C1/C3-C1c-C1b-C1w	1	0.003703704	0.9962963	
# p_C3k/C50a	1	0.003703704	1.0000000		

```

```{r}
#What is the proportion of samples that had 1 and 2 type profiles?

clean_data %>% 
 filter(coral_genus == "Pocillopora") %>% 
 filter(str_detect(name, "p_")) %>%
 group_by(sample_name) %>% 
 summarise(n = n()) %>% 
 filter(n == 1)     #320  samples have 1 type profile
 #filter(n == 2)     #4 samples have 2 type profiles

clean_data %>% 
  filter(coral_genus == "Acropora") %>% 
  filter(str_detect(name, "p_")) %>%
  group_by(sample_name) %>% 
  summarise(n = n()) %>% 
 #filter(n == 1)     #250 samples have 1 type profile
 filter(n == 2)     #10 samples have 2 type profiles 
```

## Majority Sequences 
```{r}
#pverrucosa 
clean_data %>% 
  filter(mtORF == "Pverrucosa") %>% 
  filter(str_detect(name, c("p_"))) %>% 
  filter(str_detect(name, c("p_C1d")))

128 / veru_total 
#found as majority sequence in 84.2% of P. verrucosa samples 


#p.mea/haplotype 8a 
clean_data %>% 
 filter(mtORF == "Pmeandrina" | mtORF == "Haplotype8a") %>% 
 filter(str_detect(name, c("p_"))) %>% 
 filter(str_detect(name, c("p_C1|p_C42.2"))) 

#153 /(mean_total + hap8a_total) # 0.8895349


#acropora 
clean_data %>% 
  filter(mtORF == "Ahumilis") %>% 
    filter(str_detect(name, c("p_"))) %>% 
    filter(str_detect(name, c("p_C3k|p_C3"))) %>% 
  #summarise(mean = mean(value_rel))      #for relative proportion

#258 / humil_total
#C3k/C3 is majority sequence in 0.9923077 of all samples 
```


Table S1.
```{r}
#How many samples collected from each reef, for each type of coral species? 
meta %>% dplyr::select(c(Vial, Reef, mtORF, Lat)) %>% 
  filter(mtORF != "Unknown") %>% 
  group_by(Reef, mtORF) %>% 
  summarise(total_samples = n()) %>%
  pivot_wider(names_from = mtORF, values_from = total_samples)
```
# 3.2 UPGMA Stats
```{r}
seq_data <- clean_data %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
  
#creating an object for each species 
poci_seqs <- seq_data %>% filter(coral_genus == "Pocillopora")
pver_seqs <- seq_data %>% filter(str_detect(mtORF, "Pverrucosa"))
pmh8_seqs <- seq_data %>% filter(str_detect(mtORF, "Pmeandrina|Haplotype8a"))
acro_seqs <- seq_data %>% filter(str_detect(mtORF, "Ahumilis"))
```

## Fig2A
```{r}
#read in file 
fasta_poci <- read_fasta_df("20210612_marzonie/186_20211115_03_DBV_20211116T024440.seqs.fasta") %>%
  filter(label %in% poci_seqs$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  filter(!str_detect(label, "A|G")) %>%
  deframe() %>%
  as_dna()

#creating the tree
kdist_poci <- fasta_poci %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()

k_tree_poci <- kdist_poci %>% phangorn::upgma()

seqs_wide_poci <- poci_seqs %>%
  dplyr::select(sample_name, name, value) %>%
  filter(!str_detect(name, "A|G")) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

k_unidist_poci <- GUniFrac(seqs_wide_poci, k_tree_poci)   #GUniFrac calculates all the distances 
k_unidist_poci <- k_unidist_poci$unifracs

du_poci <- k_unidist_poci[, , "d_0.5"]    # GUniFrac with alpha 0.5 
dist_poci <- as.dist(du_poci, diag = FALSE)

# Cluster the samples
hclust_samps_poci <- upgma(du_poci)

# Make the sample tree
tree_poci <- ggtree(hclust_samps_poci, size = 0.2) +
  theme(aspect.ratio = 0.3)

# Get a sample order from ggtree
poci_sample_order <- tree_poci$data %>% filter(isTip == "TRUE") %>%
  arrange(y) %>%
  pull(label)

pocimat <- meta %>% filter(sample_name %in% tree_poci$data$label) %>%
  select(sample_name, RFLP = Species, mtORF) %>%
  mutate(RFLP = case_when(RFLP == "Pmeandrina" ~ "P. meandrina",
                          RFLP == "Pverrucosa" ~ "P. verrucosa", TRUE ~ RFLP),
         mtORF = case_when(mtORF == "Pmeandrina" ~ "P. meandrina",
                           mtORF == "Pverrucosa" ~ "P. verrucosa", TRUE ~ mtORF)) %>%
  tibble::column_to_rownames(var = "sample_name")

poci_tree_mat <- gheatmap(tree_poci, pocimat, colnames = T, width=.1, offset = -0.26)
poci_tree_mat <- poci_tree_mat + scale_fill_d3(palette = "category10", na.value = "grey90") + layout_dendrogram() + theme(legend.position = "left")

# Start plotting the composition data
plot_df_poci <- clean_data %>%
  filter(coral_genus == "Pocillopora") %>%
  mutate(sample_name = fct_relevel(sample_name, poci_sample_order))

theme_set(theme_bw())

# find the likely distinguishing seqs in here
test_df <- pver_seqs %>%
   group_by(name) %>%
   summarise(mean = mean(value_rel), n = n()) %>%
   arrange(desc(n), desc(mean))

# colour them black to check
 test_pal <- all_pal
 test_pal['C1b'] <- "#000000" 

bar_uni_poci <- 
ggplot(plot_df_poci, aes(sample_name, value_rel)) +
geom_bar(stat = "identity", aes(fill = name, colour = name)) +
theme(aspect.ratio = 0.5, legend.position = "none", axis.text.y=element_blank(), axis.ticks.y = element_blank(),
      axis.text.x=element_blank(), axis.ticks.x = element_blank(),
      axis.title.x = element_blank(), axis.title.y = element_blank(),
      panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.ticks = element_blank()) +
scale_fill_manual(values = all_pal, breaks = levels(profile_data$name)) +
scale_colour_manual(values = test_pal, breaks = levels(profile_data$name)) +
geom_hline(yintercept = 1, size = 1) +
guides(fill=guide_legend(ncol=2))

bar_uni_poci 


#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef.

poci_tree_mat / bar_uni_poci
```

## Fig 2B Acropora Symportal data 

**OBSERVATIONS: Regardless of the tree-type and unifrac combination, there is one major branch point in the tree. While this does not seem to be consistent with lat/lon, the unweighted approach seems very good at placing samples from the same lat/lons together.**

```{r}
#read in file 
fasta_acro <- read_fasta_df("20210612_marzonie/186_20211115_03_DBV_20211116T024440.seqs.fasta") %>%
  filter(label %in% acro_seqs$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  filter(str_sub(label, 1, 1) == "C" | str_detect(label, "_C")) %>%
  deframe() %>%
  as_dna()

# Unifracs With a kmer-based tree

kdist_acro <- fasta_acro %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()

k_tree_acro <- kdist_acro %>% phangorn::upgma()

# Get the community matrix
seqs_wide_acro <- acro_seqs %>%
  dplyr::select(sample_name, name, value) %>%
  filter(str_sub(name, 1, 1) == "C" | str_detect(name, "_C")) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

# comput unifrac distances  
k_unidist_acro <- GUniFrac(seqs_wide_acro, k_tree_acro)   #GUniFrac calculates all the distances 
k_unidist_acro <- k_unidist_acro$unifracs

du_acro <- k_unidist_acro[, , "d_0.5"]    # GUniFrac with alpha 0.5
dist_acro <- as.dist(du_acro, diag = FALSE)


# Cluster the samples
hclust_samps_acro <- upgma(du_acro)

# Make the sample tree
tree_acro <- ggtree(hclust_samps_acro, size = 0.2) +
  theme(aspect.ratio = 0.3) + layout_dendrogram()

# Get a sample order from ggtree
acro_sample_order <- tree_acro$data %>% filter(isTip == "TRUE") %>%
  arrange(y) %>%
  pull(label)

# Start plotting the composition data
plot_df_acro <- clean_data %>%
  filter(str_detect(Species, "Ahumilis")) %>%
  mutate(sample_name = fct_relevel(sample_name, acro_sample_order))

theme_set(theme_bw())


# find the likely distinguishing seqs in here
test_df <- acro_seqs %>%
   group_by(name) %>%
   summarise(mean = mean(value_rel), n = n()) %>%
   arrange(desc(n), desc(mean))

# colour them black to check
 test_pal <- all_pal
 test_pal['C21ab'] <- "#000000" 

bar_uni_acro <- 
ggplot(plot_df_acro, aes(sample_name, value_rel)) +
geom_bar(stat = "identity", aes(fill = name, colour = name)) +
theme(aspect.ratio = 0.5, legend.position = "none", axis.text.y=element_blank(), axis.ticks.y = element_blank(),
      axis.text.x=element_blank(), axis.ticks.x = element_blank(),
      axis.title.x = element_blank(), axis.title.y = element_blank(),
      panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.ticks = element_blank()) +
scale_fill_manual(values = test_pal, breaks = levels(profile_data$name)) +
scale_colour_manual(values = test_pal, breaks = levels(profile_data$name)) +
geom_hline(yintercept = 1, size = 1) +
guides(fill=guide_legend(ncol=2))

#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef. 

tree_acro / bar_uni_acro
```


## K groups for Acropora 
```{r}
#there is clear division of symbiont communities. we will identify which k-group and then see how non-profile sequences vary between the two groups - which seems to be the predominant feature in the split. 

# Cluster the samples
hclust_samps_acro <- upgma(du_acro)

# Get a sample order from ggtree
ggtree_samps_acro <- ggtree::ggtree(hclust_samps_acro)$data %>%
  filter(isTip == "TRUE") %>%
  arrange(y)

# Make the sample tree
tree_acro <- ggtree(hclust_samps_acro, size = 0.2) +
  scale_x_reverse() +
  theme(aspect.ratio = 4)

```


```{r}
library(dendextend)

#here we are taking the output of the upgma for acropora which clusters samples by unifrac distance and putting it into 'cutree' 
#k value is how many groups you want membership for. We need to set k to 10 because each of the outliers form their own distinct k groups. 
cu_acro <- cutree(hclust_samps_acro, k = 10)
#cutree gives a named vector with sample sames and their membership to groups (1-8 in this case)

hclust_samps_acro %>% 
  as.dendrogram() %>% 
  set("branches_k_color", k = 10, value = pal_d3("category10")(10)) %>% 
  plot(main = "Group membership")


grouplist_acro <- enframe(cu_acro) %>% 
  dplyr::rename(kgroup = value) %>% 
  dplyr::rename(sample_name = name)

#save(grouplist_acro, file = "Data/grouplist_acro.RData")
#change value to k group. add to metadata 
```


```{r}
#joining clean data with the kgroups for acropora 
clean_data <- left_join(clean_data, grouplist_acro)

#differences in k-group non-profile sequences 
clean_data %>%
  filter(str_detect(name, "non")) %>%
  filter(coral_genus == "Acropora") %>% 
  group_by(kgroup) %>%
  summarise(mean = mean(value_rel)) #%>% 
  #summarise(n =n())

#non-profile abundance in the two difference clusters (1 = left side of tree, 2 = right side of tree)
# kgroup1	0.20711430			
# kgroup2	0.29029638
```

## Pver distance matrix

```{r}
fasta_pver <- read_fasta_df("20210612_marzonie/186_20211115_03_DBV_20211116T024440.seqs.fasta") %>%
  filter(label %in% pver_seqs$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  filter(!str_detect(label, "A|G")) %>%
  deframe() %>%
  as_dna()

#creating the tree
kdist_pver <- fasta_pver %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()

k_tree_pver <- kdist_pver %>% phangorn::upgma()

seqs_wide_pver <- pver_seqs %>%
  dplyr::select(sample_name, name, value) %>%
  filter(!str_detect(name, "A|G")) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

k_unidist_pver <- GUniFrac(seqs_wide_pver, k_tree_pver)   #GUniFrac calculates all the distances 
k_unidist_pver <- k_unidist_pver$unifracs

du_pver <- k_unidist_pver[, , "d_0.5"]    # GUniFrac with alpha 0.5 
dist_pver <- as.dist(du_pver, diag = FALSE)
```

## Pmean/hap8a distance matrix

```{r}
fasta_pmh8 <- read_fasta_df("20210612_marzonie/186_20211115_03_DBV_20211116T024440.seqs.fasta") %>%
  filter(label %in% pmh8_seqs$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  filter(!str_detect(label, "A|G")) %>%
  deframe() %>%
  as_dna()

#creating the tree
kdist_pmh8 <- fasta_pmh8 %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()

k_tree_pmh8 <- kdist_pmh8 %>% phangorn::upgma()

seqs_wide_pmh8 <- pmh8_seqs %>%
  dplyr::select(sample_name, name, value) %>%
  filter(!str_detect(name, "A|G")) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

k_unidist_pmh8 <- GUniFrac(seqs_wide_pmh8, k_tree_pmh8)   # GUniFrac calculates all the distances 
k_unidist_pmh8 <- k_unidist_pmh8$unifracs

du_pmh8 <- k_unidist_pmh8[, , "d_0.5"]    # GUniFrac with alpha 0.5 
dist_pmh8 <- as.dist(du_pmh8, diag = FALSE)
```

# 3.3 Marker alignment psbAncr

```{r}
#psba txt files forward and reverse
f_all <- sort(list.files(path = "psba txt files/", pattern = "Forw.txt", full.names = TRUE))

r_all <- sort(list.files(path = "psba txt files/", pattern = "Rev.txt", full.names = TRUE))


f_all_fasta <- f_all %>%
  map(read_fasta_df) %>% # read in all the files
  purrr::reduce(rbind) # reduce with rbind into one dataframe

r_all_fasta <- r_all %>%
  map(read_fasta_df) %>% # read in all the files
  purrr::reduce(rbind) # reduce with rbind into one dataframe
```

## Trimming parameters psba
```{r}
# apply the trimming parameters to start and end of the sequences to improve consensus

f_all_fasta_sub <- f_all_fasta %>%
  mutate(sequence = case_when(str_detect(label, "psba1_A12") ~ str_sub(sequence, start = 30, end = 550),
                              str_detect(label, "psba1_B02") ~ str_sub(sequence, start = 30, end = 700),
                              str_detect(label, "psba1_B07") ~ str_sub(sequence, start = 30, end = 600),
                              str_detect(label, "psba1_B09") ~ str_sub(sequence, start = 30, end = 650),
                              str_detect(label, "psba1_B09") ~ str_sub(sequence, start = 30, end = 600),
                              str_detect(label, "psba1_B10") ~ str_sub(sequence, start = 30, end = 650),
                              str_detect(label, "psba1_C12") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_D10") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_D11") ~ str_sub(sequence, start = 30, end = 545),
           TRUE ~ str_sub(sequence, start = 30, end = 800)))

r_all_fasta_sub <- r_all_fasta %>%
  mutate(sequence = case_when(str_detect(label, "psba1_A04") ~ str_sub(sequence, start = 30, end = 450),
                              str_detect(label, "psba1_A06") ~ str_sub(sequence, start = 30, end = 400),
                              str_detect(label, "psba1_A07") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_A08") ~ str_sub(sequence, start = 30, end = 450),
                              str_detect(label, "psba1_A08") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_A09") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_A12") ~ str_sub(sequence, start = 30, end = 550),
                              str_detect(label, "psba1_B02") ~ str_sub(sequence, start = 30, end = 300),
                              str_detect(label, "psba1_B03") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_B06") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_B09") ~ str_sub(sequence, start = 30, end = 450),
                              str_detect(label, "psba1_B10") ~ str_sub(sequence, start = 30, end = 450),
                              str_detect(label, "psba1_B11") ~ str_sub(sequence, start = 30, end = 450),
                              str_detect(label, "psba1_C04") ~ str_sub(sequence, start = 30, end = 225),
                              str_detect(label, "psba1_D05") ~ str_sub(sequence, start = 30, end = 300),
                              str_detect(label, "psba1_D11") ~ str_sub(sequence, start = 30, end = 425),
                              str_detect(label, "psba1_E03") ~ str_sub(sequence, start = 30, end = 550),
                              str_detect(label, "psba1_F02") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_F08") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_G01") ~ str_sub(sequence, start = 30, end = 300),
                              str_detect(label, "psba1_H01") ~ str_sub(sequence, start = 30, end = 550),
                              str_detect(label, "psba1_H02") ~ str_sub(sequence, start = 30, end = 500),
                              str_detect(label, "psba1_H10") ~ str_sub(sequence, start = 30, end = 450),
                              TRUE ~ str_sub(sequence, start = 30, end = 600)))

# convert to format for DECIPHER and reverse complement the reverse sequence

f_dss <- f_all_fasta_sub %>%
  deframe() %>%
  as_dna() %>%
  dna_to_DNAStringset()

r_dss <- r_all_fasta_sub %>%
  deframe() %>%
  as_dna() %>%
  dna_to_DNAStringset() %>%
  reverseComplement()

pair_list <- list()
for(i in 1:length(f_dss)){
  ss <- DNAStringSet(c(f_dss[i], r_dss[i]))
  pair_list[[i]] <- ss
}

# Align the sample pairs
alignment_list <- list()
for(i in 1:length(pair_list)){
  alignment <- AlignSeqs(pair_list[[i]], verbose = FALSE)
  alignment_list[[i]] <- alignment
}

# View the alignments
aligned_df <- data.frame()
for(i in 1:length(alignment_list)){
  a_pair <- alignment_list[[i]] %>% writeXStringSet("temp_file.fasta")
  a_df <- read_fasta_df("temp_file.fasta")
  aligned_df <- rbind(aligned_df, a_df)
}

aligned_plotting <- aligned_df %>%
  mutate(sample_id = str_sub(label, 23, 25)) %>% # create a metadata column that identifies the sample
  mutate(label = str_sub(label, 23, 31))
  
# Create profile key
key <- aligned_plotting %>%
  tibble::rownames_to_column(var = "id")

# Create long dataframe for ggplot
long_sequences <- str_split(aligned_plotting$sequence, "") %>%
  reshape2::melt() %>%
  group_by(L1) %>%
  mutate(x = row_number(),
         L1 = as.character(L1)) %>%
  left_join(., key, by = c("L1" = "id")) %>%
  ungroup()

# Plot alignment
ggplot(long_sequences, aes(y = label, x = x)) +
      geom_tile(aes(fill = value), size = 1, name = "base") +
      facet_wrap(~ sample_id, nrow = 12, scales = "free_y") +
      scale_fill_manual(values = palette) +
      theme(aspect.ratio = 0.3,
            axis.title.y = element_blank()) +
      scale_x_continuous(expand = c(0, 0)) +
    xlab("Position")
```

##Exclude list

```{r}
# Sample list that we may want to exclude based on f and r alignments: B12, C04, G01, D06, D11
exclude_list <- c("B12", "D06", "C04", "F02", "B02", "B03")

align_list_final <- list()
for(i in 1:length(alignment_list)){
  if(str_sub(names(alignment_list[[i]][1]), 23, 25) %in% exclude_list) align_list_final[[i]] <- NULL else align_list_final[[i]] <- alignment_list[[i]]
}

align_list_final <- Filter(Negate(is.null), align_list_final)
```


## Create the consensus sequences

```{r}
consensus_df <- list()
for(i in 1:length(align_list_final)){
  a_con <- align_list_final[[i]] %>% ConsensusSequence()
  names(a_con) <- names(align_list_final[[i]])[1]
  consensus_df[[i]] <- a_con
}
```

## Pocillopora psba

```{r}
pocillo_meta <- meta %>%
  filter(mtORF == "Pmeandrina" | mtORF == "Pverrucosa" | mtORF == "Haplotype8a") %>%
  filter(str_detect(psba_ID, "psb"))

pocillo_names <- pocillo_meta %>% pull(psba_ID)

pocillo_cons <- list()
for(i in 1:length(consensus_df)){
  if(str_sub(names(consensus_df[[i]]), 17, 25) %in% pocillo_names) pocillo_cons[[i]] <- consensus_df[[i]] else pocillo_cons[[i]] <- NULL
}

# Keep only the pocillo psba sequences
pocillo_cons <- Filter(Negate(is.null), pocillo_cons)
```


## Poci: ITS2/psba distance matrices
```{r}
# Get consensus seqs
pocillo_df <- data.frame()
for(i in 1:length(pocillo_cons)){
  pocillo_cons[[i]] %>% writeXStringSet("temp_file.fasta")
  t_df <- read_fasta_df("temp_file.fasta")
  pocillo_df <- rbind(pocillo_df, t_df)
}

# Kmer based distance matrix
dis_psbaID <- pocillo_df %>%
  mutate(psba_ID = str_sub(label, 17, 25)) %>%
  left_join(., pocillo_meta) %>%
  select(sample_name, sequence) %>%
  deframe() %>%
  DNAStringSet() %>%
  DNAStringSet_to_DNAbin() %>%
  kmer::kdistance(k = 7) %>%
  as.matrix()

# Produce hierarchical tree
psba_upgma_tree <- phangorn::upgma(dis_psbaID)

# Subset the full matrix
du_poci_sub <- dist_subset(du_poci, psba_upgma_tree$tip.label) %>%
  as.matrix()

# Produce hierarchical tree
ITS2_upgma_tree <- phangorn::upgma(du_poci_sub)
```

## Pocillopora ITS2 Tanglegram

```{r}
untang <- untangle(dend1 = ITS2_upgma_tree %>% as.dendrogram(), dend2 = psba_upgma_tree %>% as.dendrogram, method = "step2side")
tgram <- tanglegram(untang, margin_inner = 8)
entanglement(tgram) # 0.01193893

t_order <- labels(tgram$dend1)
s_order <- labels(tgram$dend2)

tt <- as.phylo(tgram$dend1)
tt <- midpoint(tt)

st <- as.phylo(tgram$dend2)
st <- midpoint(st)

tree_meta <- pocillo_meta %>%
  filter(sample_name %in% psba_upgma_tree$tip.label) %>%
  mutate(new_lab = paste0(sample_name, "_", mtORF))

gtt <- ggtree(tt, ladderize = FALSE) 
gtt$data <- gtt$data %>% left_join(., tree_meta, by = c("label" = "sample_name"))

gtt <- gtt + geom_tiplab(size = 3, aes(label = label)) + geom_tippoint(aes(fill = mtORF), shape = 21, size = 5) + ggsci::scale_fill_d3(palette = "category20")
gst <- ggtree(st, ladderize = FALSE)

dtt <- gtt$data
dst <- gst$data

dtt$tree <- "ITS2"
dst$tree <- "psbA"

dst$x <- max(dst$x) - dst$x + max(dtt$x) + max(dtt$x) * 1

pp <- gtt + geom_tree(data = dst)

dd <- bind_rows(dtt, dst) %>%
  filter(isTip == TRUE)

dd1 <- as.data.frame(dd)

p_ip <- pp + geom_line(aes(x, y, group = label), size = 1.2, data = dd1) +
  ggsci::scale_colour_d3(palette = "category20") +
  theme(legend.position = "none")

p_ip
```

## Acropora psba

```{r}
acro_meta <- meta %>%
  filter(mtORF == "Ahumilis") %>%
  filter(str_detect(psba_ID, "psb"))

acro_names <- acro_meta %>% pull(psba_ID)

acro_cons <- list()
for(i in 1:length(consensus_df)){
  if(str_sub(names(consensus_df[[i]]), 17, 25) %in% acro_names) acro_cons[[i]] <- consensus_df[[i]] else acro_cons[[i]] <- NULL
}

# Keep only the pocillo psba sequences
acro_cons <- Filter(Negate(is.null), acro_cons)
```

## Acro: ITS2/psbA distance matrices

```{r}
# Get consensus seqs
acro_df <- data.frame()
for(i in 1:length(acro_cons)){
  acro_cons[[i]] %>% writeXStringSet("temp_file.fasta")
  t_df <- read_fasta_df("temp_file.fasta")
  acro_df <- rbind(acro_df, t_df)
}

# Kmer based distance matrix
dis_psbaID <- acro_df %>%
  mutate(psba_ID = str_sub(label, 17, 25)) %>%
  left_join(., acro_meta) %>%
  select(sample_name, sequence) %>%
  deframe() %>%
  DNAStringSet() %>%
  DNAStringSet_to_DNAbin() %>%
  kmer::kdistance(k = 7) %>%
  as.matrix()

# Produce hierarchical tree
psba_upgma_tree <- phangorn::upgma(dis_psbaID)

# Subset the full matrix
du_acro_sub <- dist_subset(du_acro, psba_upgma_tree$tip.label) %>%
  as.matrix()

# Produce hierarchical tree
ITS2_upgma_tree <- phangorn::upgma(du_acro_sub)
```

## Acropora ITS2 Tanglegram

```{r}
untang <- untangle(dend1 = ITS2_upgma_tree %>% as.dendrogram(), dend2 = psba_upgma_tree %>% as.dendrogram, method = "step2side")
tgram <- tanglegram(untang, margin_inner = 8)
entanglement(tgram) # 0.1986148

t_order <- labels(tgram$dend1)
s_order <- labels(tgram$dend2)

tt <- as.phylo(tgram$dend1)
tt <- midpoint(tt)

st <- as.phylo(tgram$dend2)
st <- midpoint(st)

tree_meta <- acro_meta %>%
  filter(sample_name %in% psba_upgma_tree$tip.label) %>%
  mutate(new_lab = paste0(sample_name, "_", mtORF))

gtt <- ggtree(tt, ladderize = FALSE) 
gtt$data <- gtt$data %>% left_join(., tree_meta, by = c("label" = "sample_name"))

gtt <- gtt + geom_tiplab(size = 3, aes(label = label))
gst <- ggtree(st, ladderize = FALSE)

dtt <- gtt$data
dst <- gst$data

dtt$tree <- "ITS2"
dst$tree <- "psbA"

dst$x <- max(dst$x) - dst$x + max(dtt$x) + max(dtt$x) * 1

pp <- gtt + geom_tree(data = dst)

dd <- bind_rows(dtt, dst) %>%
  filter(isTip == TRUE)

dd1 <- as.data.frame(dd)

p_ip <- pp + geom_line(aes(x, y, group = label), size = 1.2, data = dd1)

tgram <- tanglegram(untang, margin_inner = 8)
p_ip
```


# 3.4 PCoA 
**Here we are running a PCoA on UniFrac distances for the three communities associated with three different host groups (Pocillopora verrucosa, P. meandrina, and Acropora humilis)** 
**We are looking for patterns by reef here**

## Pver PCoA

```{r}
reef_order <- meta %>% distinct(Reef, Lat) %>%
  group_by(Reef) %>%
  summarise(Lat = mean(Lat)) %>%
  arrange(Lat) %>%
  pull(Reef)

pcoa_pver <- cmdscale(dist_pver, eig = TRUE) #this is doing 'cmds' or classic multidimensional scaling

ordiplot(pcoa_pver, display = 'sites', type = 'text')
barplot(pcoa_pver$eig, names = paste ('PCoA', 1:152), las = 3, ylab = 'eigenvalues')

MDSxy.pver <- data.frame(pcoa_pver$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta)

pverPCA <- MDSxy.pver %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1) +
   theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))



pverPCA
```

## Pmea PCoA

```{r}
pcoa_pmh8 <- cmdscale(dist_pmh8, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

ordiplot(pcoa_pmh8, display = 'sites', type = 'text')
barplot(pcoa_pmh8$eig, names = paste ('PCoA', 1:172), las = 3, ylab = 'eigenvalues')

MDSxy.pmh8 <- data.frame(pcoa_pmh8$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta)

pmh8PCA <- MDSxy.pmh8 %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1) +
   theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

pmh8PCA
```


## Ahum PCoA

```{r}
pcoa_acro <- cmdscale(dist_acro, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

ordiplot(pcoa_acro, display = 'sites', type = 'text')
barplot (pcoa_acro$eig, names = paste ('PCoA', 1:260), las = 3, ylab = 'eigenvalues')

MDSxy.acro <- data.frame(pcoa_acro$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta)

acroPCA <- MDSxy.acro %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1) 
 # scale_fill_manual(values = reef_pal) #+
 #theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

acroPCA
```
## PCoA Fig SX
```{r}
pverPCA + pmh8PCA + acroPCA
```

Fig SX. PCoA of each species symbiont communities 


# 3.3.2 Bleaching category effects 


```{r}
library("RColorBrewer")
#library("ggforce")
my_colors <- c("#F5F5F5", "#F6E8C3", "#DFC27D", "#BF812D", "#8C510A", "#543005")

pcoa_pver.b <- cmdscale(dist_pver, eig = TRUE) 

ordiplot(pcoa_pver.b, display = 'sites', type = 'text')
barplot(pcoa_pver.b$eig, names = paste ('PCoA', 1:152), las = 3, ylab = 'eigenvalues')

MDSxy.pver.b <- data.frame(pcoa_pver.b$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta) %>% 
      mutate(catBleaching = as.factor(catBleaching))


pverPCA.b <- MDSxy.pver.b %>%
  ggplot(aes(X1, X2, fill = catBleaching)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
  scale_fill_manual(values = my_colors) +
 stat_ellipse(aes(fill = catBleaching)) 

pverPCA.b <- MDSxy.pver.b %>%
  ggplot(aes(X1, X2)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
  stat_ellipse(fill = catBleaching) +
  scale_fill_manual(values = my_colors, guide = FALSE)

pverPCA.b

```

```{r}
pcoa_pmh8.b <- cmdscale(dist_pmh8, eig = TRUE)  

ordiplot(pcoa_pmh8.b, display = 'sites', type = 'text')
barplot(pcoa_pmh8.b$eig, names = paste ('PCoA', 1:172), las = 3, ylab = 'eigenvalues')

MDSxy.pmh8.b <- data.frame(pcoa_pmh8.b$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta) %>% 
    mutate(catBleaching = as.factor(catBleaching))


pmh8PCA.b <- MDSxy.pmh8.b %>%
  ggplot(aes(X1, X2, fill = catBleaching)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
  stat_ellipse() +
 # theme(legend.position = "right", aspect.ratio = 1, text = element_text(size = 15)) +     
  theme(legend.position = "none") +

     scale_fill_manual(values = my_colors)

pmh8PCA.b
```

```{r}
pcoa_acro.b <- cmdscale(dist_acro, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling
outlier_samples <- c("Plate6_D012", "Plate6_E009", "Plate6_H011", "Plate6_B012", "Plate7_D006", "Plate6_G009", "Plate7_H009", "Plate7_A010", "Plate6_D011")


ordiplot(pcoa_acro.b, display = 'sites', type = 'text')
barplot (pcoa_acro.b$eig, names = paste ('PCoA', 1:260), las = 3, ylab = 'eigenvalues')

MDSxy.acro.b <- data.frame(pcoa_acro.b$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta) %>% 
   mutate(catBleaching = as.factor(catBleaching)) %>% 
   filter(!(sample_name %in% outlier_samples)) 

acroPCA.b <- MDSxy.acro.b %>%
  ggplot(aes(X1, X2, fill = catBleaching)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
  stat_ellipse() +
  #geom_ellipse(aes(color = catBleaching), alpha = 0.2) +
  theme(legend.position = "right", aspect.ratio = 1, text = element_text(size = 15)) +
     scale_fill_manual(values = my_colors)

acroPCA.b
```


```{r}
PCA_bleach <- pverPCA.b + pmh8PCA.b + acroPCA.b 
PCA_bleach
```


# 3.4 dbRDA 
## Pver dbRDA
```{r}
#importing unifrac distances for analysis 
meta_pver <- meta %>%
  filter(mtORF == "Pverrucosa") %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  mutate(catBleaching = as.numeric(catBleaching)) %>%
  tibble::column_to_rownames(var = "sample_name") %>%
  mutate(sample_name = rownames(.))

dist_pver_ordered <- dist_subset(dist_pver, rownames(meta_pver))


# Make a correlation matrix of numeric variables
cm <- cor(meta_pver %>% dplyr::select(Depth, maxDHW, meanDHW, recent.maxDHW, 
                                      recent.meanDHW, DHW3, DHW4, DHW6, DHW8, 
                                      DHW9, rangeSST, varSST, MMM, Lat, Long))

corrplot(cm) # Clearly a lot of the DHW terms are positively related and approaching redundant
cm %>% cor()

# Check the vif scores of the full model
ord_pver_full <- dbrda(dist_pver_ordered ~ Depth + maxDHW + meanDHW + recent.maxDHW + 
                                      recent.meanDHW + DHW3 + DHW4 + DHW6 + DHW8 + 
                                      DHW9 + rangeSST + varSST + MMM + Lat + Long + catBleaching, data = meta_pver)

sort(vif.cca(ord_pver_full)) 

#catBleaching          Depth           DHW3           DHW6  recent.maxDHW           DHW9           DHW8 
      #1.113849       1.522313       9.378885      12.991857      14.007951      21.303339      21.401462 
      #  maxDHW       rangeSST           DHW4        meanDHW recent.meanDHW         varSST            MMM 
    # 28.273530      78.922668      79.975289     188.415523     345.763123     369.560091     431.829169 
         # Long            Lat 
  #  714.853784     716.722556 

#many correlated thermal history variables. We can definitely keep: depth, catBleaching as not correlated to anything strongly. 
#keep lat, remove MMM -> one variable to reflect latitudinal gradient
#keep varSST, remove rangeSST -> one variable to reflect variation throughout the year
#keep recent.maxDHW -> one variable to reflect recent thermal history (would expect to shape more than long-term based on symbiont life history)

# Reduce the model (consult the corplot and vif scores)
ord_pver <- dbrda(dist_pver_ordered ~ Lat + Depth + catBleaching + varSST + recent.maxDHW , data = meta_pver)

# Re check the new vif scores
sort(vif.cca(ord_pver))
# catBleaching         Depth recent.maxDHW           Lat        varSST 
   #  1.023056      1.044675      1.480152      1.993197      2.225752 

# Use ordistep to further refine the model
os_pver_backward <- ordistep(ord_pver, direction = "backward", permutations = 999)
anova(os_pver_backward, by = 'margin')

# Number of permutations: 999
#Model: dbrda(formula = dist_pver_ordered ~ Lat + Depth, data = meta_pver)
        #  Df SumOfSqs      F Pr(>F)   
#Lat        1   0.0883 3.1452  0.005 **
#Depth      1   0.0640 2.2809  0.029 * 
#Residual 149   4.1812   

#variance partitioning to see how much variation is explained by each factor 
varp <- varpart(dist_pver_ordered, ~Depth, ~Lat, data = meta_pver)
plot(varp, digits = 2, Xnames = c("Depth", "Lat"), bg = c("navy", "tomato"))

#extract dbRDA scores
pver_scores <- as.data.frame(scores(os_pver_backward, display = "sites")) %>%
  tibble::rownames_to_column(var = "sample_name") %>%
  left_join(., meta_pver)

#extract dbRDA vectors
pver_vectors <- as.data.frame(os_pver_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
pver_fullrda <- pver_scores %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 4, shape = 21) +
      geom_label_repel(data = pver_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.75, size = 4, segment.colour = NA) +
  #geom_text(aes(label = sample_name )) +
      geom_segment(data = pver_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
      scale_fill_viridis_c(option = "magma", direction = -1) +
  theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())


pver_fullrda

```


## Pmea Hap8 dbRDA
```{r}
#importing unifrac distances for analysis 
meta_pmh8 <- meta %>%
  filter(mtORF == "Pmeandrina" | mtORF == "Haplotype8a") %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  mutate(catBleaching = as.numeric(catBleaching)) %>%
  tibble::column_to_rownames(var = "sample_name") %>%
  mutate(sample_name = rownames(.))

dist_pmh8_ordered <- dist_subset(dist_pmh8, rownames(meta_pmh8))

# Make a correlation matrix of numeric variables
cm <- cor(meta_pmh8 %>% select(Depth, maxDHW, meanDHW, recent.maxDHW, 
                                recent.meanDHW, DHW3, DHW4, DHW6, DHW8, 
                                DHW9, rangeSST, varSST, MMM, Lat, Long))

corrplot(cm) # Clearly a lot of the DHW terms are positively related and approaching redundant

# Check the vif scores of the full model
ord_pmh8_full <- dbrda(dist_pmh8_ordered ~ Depth + maxDHW + meanDHW + recent.maxDHW + 
                                      recent.meanDHW + DHW3 + DHW4 + DHW6 + DHW8 + 
                                      DHW9 + rangeSST + varSST + MMM + Lat + Long + catBleaching, data = meta_pmh8)
sort(vif.cca(ord_pmh8_full))


sort(vif.cca(ord_pmh8_full))
 #initial vif scores are not good - choose to reduce the model based on important variables. 
 #catBleaching          Depth           DHW6           DHW8           DHW9           DHW4           DHW3 
      #1.193880       1.839450       6.857242      10.464858      10.630817      11.495987      14.528088 
# recent.maxDHW         maxDHW       rangeSST        meanDHW recent.meanDHW         varSST            MMM 
     #19.817628      23.628139      92.408082     116.114436     189.852052     195.482726     398.335012 
        #  Long            Lat 
   # 605.292312     724.583261 

# Reduce the model (consult the corplot and vif scores)
ord_pmh8 <- dbrda(dist_pmh8_ordered ~ Lat + Depth + catBleaching + varSST + recent.maxDHW + Species, data = meta_pmh8)

## SPECIES NOT SIGNIFICANT so we continue using as a complex for p.mea and haplotype 8a

# Re check the new vif scores
sort(vif.cca(ord_pmh8))
#new vif scores:  catBleaching          Lat       varSST 
                    # 1.121738     3.230635     3.280192 

#remove species now and continue 
ord_pmh8 <- dbrda(dist_pmh8_ordered ~ Lat + Depth + catBleaching + varSST + recent.maxDHW, data = meta_pmh8)

# Use ordistep to further refine the model
ord_pmh8_backward <- ordistep(ord_pmh8, direction = "backward", permutations = 999)
anova(ord_pmh8_backward, by = 'margin')

#Model: dbrda(formula = dist_pmh8_ordered ~ Lat + Depth + catBleaching + varSST, data = meta_pmh8)
            #  Df SumOfSqs       F Pr(>F)    
#Lat            1   0.6825 26.7498  0.001 ***
#Depth          1   0.0533  2.0895  0.068 .  
#catBleaching   1   0.1608  6.3031  0.003 ** 
#varSST         1   0.1936  7.5903  0.001 ***
#Residual     167   4.2607 

#remove depth for final model so that it does not appear in the dbRDA fig
ord_pmh8 <- dbrda(dist_pmh8_ordered ~ Lat + catBleaching + varSST + recent.maxDHW, data = meta_pmh8)
ord_pmh8_backward <- ordistep(ord_pmh8, direction = "backward", permutations = 999)
anova(ord_pmh8_backward, by = 'margin')

#Model: dbrda(formula = dist_pmh8_ordered ~ Lat + catBleaching + varSST, data = meta_pmh8)
             # Df SumOfSqs       F Pr(>F)    
#Lat            1   0.7156 27.8678  0.001 ***
#catBleaching   1   0.1600  6.2327  0.001 ***
#varSST         1   0.1895  7.3803  0.002 ** 
#Residual     168   4.3140   

#final model for varpart figure
ord_pmh8 <- dbrda(dist_pmh8_ordered ~ Lat + catBleaching + varSST, data = meta_pmh8)
ord_pmh8_backward <- ordistep(ord_pmh8, direction = "backward", permutations = 999)
anova(ord_pmh8_backward, by = 'margin')

#variance partitioning: how much does each variable explain in the model? residuals? 
varp <- varpart(dist_pmh8_ordered, ~Lat, ~catBleaching, ~varSST, data = meta_pmh8)
plot(varp, digits = 2, Xnames = c("Lat", "catBleaching", "varSST"), bg = c("navy", "tomato", "orange"))

#extract scores from dbRDA 
pmh8_scores <- as.data.frame(scores(ord_pmh8_backward, display = "sites")) %>%
  tibble::rownames_to_column(var = "sample_name") %>%
  left_join(., meta_pmh8)

#extract vectors from dbRDA 
pmh8_vectors <- as.data.frame(ord_pmh8_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
pmh8_fullrda <- pmh8_scores %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 4, shape = 21) +
        geom_label_repel(data = pmh8_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = pmh8_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
      theme(aspect.ratio = 1, text = element_text(size = 15)) +
      guides(fill = guide_colorbar (reverse = T)) +
      scale_fill_viridis_c(option = "magma", direction = -1) +
     theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())

pmh8_fullrda
```



## Ahum dbRDA

```{r}
library(ggrepel)

#identify 7 outlier samples and remove from data set
outlier_samples <- c("Plate6_D012", "Plate6_E009", "Plate6_H011", "Plate6_B012", "Plate7_D006", "Plate6_G009", "Plate7_H009", "Plate7_A010", "Plate6_D011")

#importing unifrac distances for analysis 
meta_acro <- meta %>%
  filter(mtORF == "Ahumilis") %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  filter(!(sample_name %in% outlier_samples)) %>%
  tibble::column_to_rownames(var = "sample_name") %>%
  mutate(sample_name = rownames(.))

dist_acro_ordered <- dist_subset(dist_acro, rownames(meta_acro))

# Make a correlation matrix of numeric variables
cm <- cor(meta_acro %>% select(Depth, maxDHW, meanDHW, recent.maxDHW, 
                                recent.meanDHW, DHW3, DHW4, DHW6, DHW8, 
                                DHW9, rangeSST, varSST, MMM, Lat, Long))

corrplot(cm) # Clearly a lot of the DHW terms are positively related and approaching redundant

# Check the vif scores of the full model
ord_acro_full <- dbrda(dist_acro_ordered ~ Depth + maxDHW + meanDHW + recent.maxDHW + 
                                      recent.meanDHW + DHW3 + DHW4 + DHW6 + DHW8 + 
                                      DHW9 + rangeSST + varSST + MMM + Lat + Long + catBleaching, data = meta_acro)
sort(vif.cca(ord_acro_full))

#catBleaching          Depth           DHW6           DHW8           DHW3           DHW4           DHW9 
     # 1.527296       1.630147       5.110959       6.717120       7.561038      10.160354      15.645481 
 #recent.maxDHW         maxDHW        meanDHW recent.meanDHW         varSST       rangeSST           Long 
    # 17.505177      29.451193      68.840060     119.062603     185.581875     377.190140     868.902286 
        #   MMM            Lat 
  # 1133.882152    2951.345506 

# Reduce the model (consult the corplot and vif scores)
ord_acro <- dbrda(dist_acro_ordered ~  Depth + catBleaching + varSST + recent.maxDHW + Lat, data = meta_acro)

# Re check the new vif scores
sort(vif.cca(ord_acro))

# catBleaching recent.maxDHW        varSST           Lat 
   #  1.112221      1.536088      1.811783      2.499779 
     
# Use ordistep to further refine the model
ord_acro_backward <- ordistep(ord_acro, direction = "backward", permutations = 999)
anova(ord_acro_backward, by = 'margin')

#Model: dbrda(formula = dist_acro_ordered ~ Depth + catBleaching + varSST + recent.maxDHW + Lat, data = meta_acro)
             #  Df SumOfSqs       F Pr(>F)    
#Depth           1   0.0818  2.1703  0.056 .  
#catBleaching    1   0.1016  2.6967  0.035 *  
#varSST          1   0.1477  3.9213  0.004 ** 
#recent.maxDHW   1   0.7544 20.0227  0.001 ***
#Lat             1   0.2664  7.0700  0.001 ***
#Residual      245   9.2312     

#re-run and remove depth so that it doesn't plot in the dbRDA 
ord_acro <- dbrda(dist_acro_ordered ~ catBleaching + varSST + recent.maxDHW + Lat, data = meta_acro)

#final model 
ord_acro_backward <- ordistep(ord_acro, direction = "backward", permutations = 999)
anova(ord_acro_backward, by = 'margin')

#Model: dbrda(formula = dist_acro_ordered ~ catBleaching + varSST + recent.maxDHW + Lat, data = #meta_acro)
             #  Df SumOfSqs       F Pr(>F)    
#catBleaching    1   0.1013  2.6770  0.038 *  
#varSST          1   0.1490  3.9352  0.007 ** 
#recent.maxDHW   1   0.8356 22.0730  0.001 ***
#Lat             1   0.3050  8.0568  0.001 ***
#Residual      246   9.3130   

#variance partitioning: how much does each variable explain in the model? residuals? 
varp <- varpart(dist_acro_ordered, ~Lat, ~varSST, ~recent.maxDHW, ~catBleaching, data = meta_acro)
plot(varp, digits = 2, Xnames = c("Lat", "varSST", "recent.maxDHW", "catBleaching"), bg = c("navy", "tomato", "orange", "green"))

#extract scores from dbRDA 
acro_scores <- as.data.frame(scores(ord_acro_backward, display = "sites")) %>%
  tibble::rownames_to_column(var = "sample_name") %>%
  left_join(., meta_acro)

#extract vectors from dbRDA 
acro_vectors <- as.data.frame(ord_acro_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
acro_fullrda <- acro_scores %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 4, shape = 21) +
      geom_label_repel(data = acro_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 1, size = 4, segment.colour = NA) +
     geom_segment(data = pmh8_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
      theme(aspect.ratio = 1, text = element_text(size = 15)) +
      guides(fill = guide_colorbar (reverse = T)) +
      scale_fill_viridis_c(option = "magma", direction = -1) +
     theme(legend.position = "right") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())

acro_fullrda
```


## Fig 4 dbRDA

```{r}
dbrda <- pver_fullrda + pmh8_fullrda + acro_fullrda 
dbrda
```


# 3.5 Network analysis 
```{r, warning=FALSE}
library(ggraph)
library(igraph)
library(tidyverse)
library(tidygraph)
library(assertthat)
library(purrr)
library(ggplot2)
library(dplyr)
```

## Pver Network
```{r}
#list of sequences per reef. 
pver_seqreef <- pver_seqs %>% 
distinct(name, Reef)

#removing sequences that are abundant across 11 or more reefs (12 total for pver), as these sequences will not be 'diagnostic' if present across most reefs 
remove_list <- pver_seqreef %>% 
  filter(!str_detect(name, "A|G")) %>%
  dplyr::count(name) %>% 
  filter(n >= 11) %>% 
  mutate(name = as.character(name)) %>% 
  pull(name)

#within each reef, get the sum of sequences across all samples collected. 
pver_reefseqs = pver_seqs %>%  
 filter(!(name %in% remove_list)) %>%
  select(name, Reef, sample_name, value ) %>%
  group_by(Reef, name) %>%
  summarise(value = sum(value))  %>%
  select(from = name, to = Reef, value)

pver_network <- pver_reefseqs %>% 
  as_tbl_graph() %>% # convert to tidygraph format
   activate(nodes) %>%
   mutate(attribute = case_when(str_detect(name, "Bougainville|Chilcott|Flinders|Frederick|Herald|Holmes|Lihou|Marion|Moore|Osprey|Saumarez|Willis|Wreck") ~ "Reef", 
                                TRUE ~ "Sequence"), # add node attribute info
          text_label = case_when(attribute == "Reef" ~ name, TRUE ~ ""),
          centrality = centrality_degree()) %>% # can measure which nodes/reefs are 'central'
  ggraph(layout = "fr") +
   geom_edge_link(aes(width = value, alpha = value)) +
   scale_edge_width(range = c(0.2, 2.5)) + # control size
   geom_node_point(aes(shape = attribute, fill = centrality), size = 4) +
  geom_node_text(aes(label = text_label), repel = TRUE) +
   scale_shape_manual(values = c(21, 22)) +
  scale_fill_viridis_c(option = "plasma")

pver_network
```


## Pmea Network
```{r}
#list of sequences per reef. 
pmh8_seqreef <- pmh8_seqs %>% 
distinct(name, Reef)

#removing sequences that are abundant across 12 or more reefs (13 total for pmea/h8), as these sequences will not be 'diagnostic' if present across many reefs 
remove_list <- pmh8_seqreef %>% 
  filter(!str_detect(name, "A|G")) %>%
  dplyr::count(name) %>% 
  filter(n >= 12) %>% 
  mutate(name = as.character(name)) %>% 
  pull(name)

#within each reef, get the sum of sequences across all samples collected. 
pmh8_reefseqs = pmh8_seqs %>%  
 filter(!(name %in% remove_list)) %>%
  select(name, Reef, sample_name, value ) %>%
  group_by(Reef, name) %>%
  summarise(value = sum(value))  %>%
  select(from = name, to = Reef, value)

pmh8_network <- pmh8_reefseqs %>% 
  as_tbl_graph() %>% # convert to tidygraph format
   activate(nodes) %>%
   mutate(attribute = case_when(str_detect(name, "Bougainville|Chilcott|Flinders|Frederick|Herald|Holmes|Lihou|Marion|Moore|Osprey|Saumarez|Willis|Wreck") ~ "Reef", 
                                TRUE ~ "Sequence"), # add node attribute info
          text_label = case_when(attribute == "Reef" ~ name, TRUE ~ ""),
          centrality = centrality_degree()) %>% # can measure which nodes/reefs are 'central'
  ggraph(layout = "fr") +
   geom_edge_link(aes(width = value, alpha = value)) +
   scale_edge_width(range = c(0.2, 2.5)) + # control size
   geom_node_point(aes(shape = attribute, fill = centrality), size = 4) +
  geom_node_text(aes(label = text_label), repel = TRUE) +
    #geom_node_label(aes(label = class), repel = TRUE) +
   scale_shape_manual(values = c(21, 22)) +
  scale_fill_viridis_c(option = "plasma")

pmh8_network
```


## A hum Network
```{r}
#list of sequences per reef. 
acro_seqreef <- acro_seqs %>% 
distinct(name, Reef)

#removing sequences that are abundant across 10 or more reefs (11 total reefs for ahum), as these sequences will not be 'diagnostic' if present across many reefs 
remove_list <- acro_seqreef %>% 
  filter(!str_detect(name, "A|G")) %>%
  dplyr::count(name) %>% 
  filter(n >= 10) %>% 
  mutate(name = as.character(name)) %>% 
  pull(name)

#within each reef, get the sum of sequences across all samples collected. 
acro_reefseqs = acro_seqs %>%  
 filter(!(name %in% remove_list)) %>%
  select(name, Reef, sample_name, value ) %>%
  group_by(Reef, name) %>%
  summarise(value = sum(value))  %>%
  select(from = name, to = Reef, value)

acro_network <- acro_reefseqs %>% 
  as_tbl_graph() %>% # convert to tidygraph format
   activate(nodes) %>%
   mutate(attribute = case_when(str_detect(name, "Bougainville|Chilcott|Flinders|Frederick|Herald|Holmes|Lihou|Marion|Moore|Osprey|Saumarez|Willis|Wreck") ~ "Reef", 
                                TRUE ~ "Sequence"), # add node attribute info
          text_label = case_when(attribute == "Reef" ~ name, TRUE ~ ""),
          centrality = centrality_degree()) %>% # can measure which nodes/reefs are 'central'
  ggraph(layout = "fr") +
   geom_edge_link(aes(width = value, alpha = value)) +
   scale_edge_width(range = c(0.2, 2.5)) + # control size
   geom_node_point(aes(shape = attribute, fill = centrality), size = 4) +
    geom_node_text(aes(label = text_label), repel = TRUE) +
   scale_shape_manual(values = c(21, 22)) +
  scale_fill_viridis_c(option = "plasma")

acro_network
```

## Facet wrap by species
```{r}
#Need to create a new dataframe with all the different species networks. We have already filtered n reefs - 1 for each species. 
library(tidyr)

pmh8_reefseqs <- pmh8_reefseqs %>% 
  mutate(Species = "Pmea")
pmh8_reefseqs <- unite(pmh8_reefseqs, col = 'from', c('from', 'Species'), sep= '_') %>% 
  mutate(Species = "Pmea") %>% 
  unite(col = "to", c('to', 'Species'), sep = '_' )

pver_reefseqs <- pver_reefseqs %>% 
  mutate(Species = "Pver") %>% 
  unite(col = 'from', c('from', 'Species'), sep= '_') %>% 
  mutate(Species = "Pver") %>% 
  unite(col = "to", c('to', 'Species'), sep = '_' )

acro_reefseqs <- acro_reefseqs %>% 
  mutate(Species = "Ahum") %>% 
  unite(col = 'from', c('from', 'Species'), sep= '_') %>% 
  mutate(Species = "Ahum") %>% 
  unite(col = "to", c('to', 'Species'), sep = '_' )

poci_reefseqs <- full_join(pmh8_reefseqs, pver_reefseqs)

network_reefseqs <- full_join(poci_reefseqs, acro_reefseqs)
```


## Fig 5 Network analysis
```{r}
#need to adjust dimensions here for figure. Also need to have consistent value plotting across all species networks so line width (value) is consistent for all three panels. 
network_reefseqs
```


```{r}
full_network <- network_reefseqs %>% 
  as_tbl_graph() %>% # convert to tidygraph format
   activate(nodes) %>%
   mutate(attribute = case_when(str_detect(name, "Bougainville|Chilcott|Flinders|Frederick|Herald|Holmes|Lihou|Marion|Moore|Osprey|Saumarez|Willis|Wreck") ~ "Reef", 
                                TRUE ~ "Sequence"), # add node attribute info
          text_label = case_when(attribute == "Reef" ~ name, TRUE ~ ""),
          centrality = centrality_degree()) %>% # can measure which nodes/reefs are 'central'
  ggraph(layout = "fr") +
    geom_node_text(aes(label = text_label), repel = TRUE) +
   #geom_text(aes(label = text_label)) +
   geom_edge_link(aes(width = value, alpha = value)) +
   scale_edge_width(range = c(0.2, 2.5)) + # control size
   geom_node_point(aes(shape = attribute, fill = centrality), size = 4) +
   scale_shape_manual(values = c(21, 22)) +
  scale_fill_viridis_c(option = "plasma") 

full_network
```


#3.6 Schematic Map
```{r}
library(dendextend)
scales::show_col(ggsci::pal_d3("category10")(10))
```


```{r}
poci_dend <- as.dendrogram(hclust_samps_poci)
poci_dend <- color_branches(poci_dend, k = 10, col = ggsci::pal_d3(palette = "category10"))
plot(poci_dend)

poci_k <- data.frame(sample_name = labels(poci_dend),
                     k = dendextend::get_leaves_branches_col(poci_dend)) %>%
  mutate(k_id = case_when(k == "#2CA02CFF" ~ "ClatN",
                          k == "#9467BDFF" ~ "ClatS",
                          k == "#8C564BFF" ~ "Cpac",
                          TRUE ~ "outliers")) %>%
  filter(k_id != "outliers") %>%
  left_join(., meta) %>%
  dplyr::select(sample_name, k_id, k, Reef, Lat, Long, mtORF)

acro_dend <- as.dendrogram(hclust_samps_acro)
acro_dend <- color_branches(acro_dend, k = 10, col = ggsci::pal_d3(palette = "category10"))
plot(acro_dend)

acro_k <- data.frame(sample_name = labels(acro_dend),
                     k = dendextend::get_leaves_branches_col(acro_dend)) %>%
  mutate(k_id = case_when(k == "#D62728FF" ~ "C3A",
                          k == "#9467BDFF" ~ "C3B",
                          TRUE ~ "outliers")) %>%
  filter(k_id != "outliers") %>%
  left_join(., meta) %>%
  dplyr::select(sample_name, k_id, k, Reef, Lat, Long, mtORF)

k_map <- rbind(poci_k, acro_k)
```

```{r}
library(phytools)
library(ape)
library(mapdata)
```


##Simplified Phlyotree
```{r}
#the simplified tree for symbionts 
simple_tree <- "((C3B, C3A),(Cpac, (ClatS, ClatN)));"
writeLines(simple_tree, "simple_tree.nwk")
simple_tree <- ape::read.tree("simple_tree.nwk")

rooted_cladogram = ape::compute.brlen(simple_tree)
plot(rooted_cladogram)

#now using phylotools to get coordinates onto map
coords <- k_map %>% mutate(Lat = -Lat) %>% dplyr::select(lat = Lat, lon = Long) %>%
  as.matrix()

rownames(coords) <- k_map$k_id

obj <- phylo.to.map(rooted_cladogram, coords, database = "worldHires", regions = "Australia", xlim = c(145, 167), ylim = c(-25, -10), plot = FALSE)

plot(obj, direction = "rightwards", fsize = 0.6)

#https://stackoverflow.com/questions/68021264/formatting-phylogeny-to-map-projection-phylo-to-plot-or-alternate-method-in/68231584?noredirect=1#comment120658622_68231584
```

```{r}
library(sf)
library(raster)
library(sp)
#read in shape files for Coral Sea 
CS_feat <- st_read("3dgbr_geomorph/shape/qld_gbrwha_cscz.shp")
CS_dryreef <- st_read("3dgbr_geomorph/shape/coralsea_dryreef.shp")
CS_reef <- st_read ("3dgbr_geomorph/shape/coralsea_reef.shp")
```

## Ocean current map
```{r}

# function to compute coordinates of arrow lines
arrowCOORD = function(x,y,r, s=0.08) {
  
  ENDx=x+sin(deg2rad(r))*s
  ENDy=y+cos(deg2rad(r))*s
  
  STAx=x-sin(deg2rad(r))*s
  STAy=y-cos(deg2rad(r))*s
  
  ar1X = ENDx+sin(deg2rad(r+135))*(s/2)
  ar1Y = ENDy+cos(deg2rad(r+135))*(s/2)
  
  ar2X = ENDx+sin(deg2rad(r-135))*(s/2)
  ar2Y = ENDy+cos(deg2rad(r-135))*(s/2)
  
  return(list('ENDx'=ENDx,'ENDy'=ENDy,'STAx'=STAx,'STAy'=STAy,'ar1X'=ar1X,'ar1Y'=ar1Y,'ar2X'=ar2X,'ar2Y'=ar2Y))
}

# function to convert deg to rad 
deg2rad = function(deg) {
  return((pi * deg) / 180)
}


# load area of interest, create polygon
AOI=extent(c(143, 167, -25, -10))

# Set spatial resoltion of arrows
RES = 0.5

# high resolution
SCD=raster('scD01.tif')
SCV=raster('scV01.tif')

# crop rasters to AOI
SCD=crop(SCD, AOI)
SCV=crop(SCV, AOI)

# create vectors defining positions (LON, LAT) of every arrow
LON = seq(AOI[1], AOI[2], by=RES)
LAT = seq(AOI[3], AOI[4], by=RES)

# create color palette of scv
colorS = colorRampPalette(c('lightblue', 'purple'))(10)
names(colorS) = seq(0,max(SCV[],na.rm=T), length.out=10)

#plot the base map 
plot(SCV)

# function to add one arrow at the time to the map
for (X in LON) {
  for (Y in LAT) {

    DIR=raster::extract(SCD, cbind(X,Y)) # extract direction
    VEL=raster::extract(SCV, cbind(X,Y)) # extract velocity 
    
    AC=arrowCOORD(X,Y,DIR, s = 0.2) # calculate arrow lines
    
    COL= which.min(VEL>as.numeric(names(colorS))) # find color of arrow based on velocity
  
    # add colored arrow lines
    lines(c(AC$STAx,AC$ENDx), c(AC$STAy,AC$ENDy), col=colorS[COL], lwd=2) 
    lines(c(AC$ar1X,AC$ENDx), c(AC$ar1Y,AC$ENDy), col=colorS[COL], lwd=2)
    lines(c(AC$ar2X,AC$ENDx), c(AC$ar2Y,AC$ENDy), col=colorS[COL], lwd=2)
    
  }
}

#plot CS features over the arrows 
plot(CS_feat, add=TRUE, col = "black")
plot(CS_dryreef, add=TRUE, col = "black")
plot(CS_reef, add=TRUE, col = "grey60")
#option to also add gbr features - but i think cleaner without 
```


```{r}
#need code to get relative abundance for c. lat N and c. lat S. 
#then make pie charts like the map 
# put pie charts in via inkscape

# the proportion of samples that have Clat N vs S
library(wesanderson)
palette = wes_palette("Darjeeling1")

poci_k.pie <- poci_k %>% 
 # filter(k_id != "Cpac") %>% 
  group_by(Reef, k_id) %>% 
  dplyr::summarise(n = n())

poci_k.pie

ggplot(poci_k.pie, aes(x = "", y = n, fill = factor(k_id))) +
  geom_bar(position="fill", stat="identity") + coord_polar("y")+
  facet_wrap( ~ Reef) +
  scale_fill_manual(values = palette) +
  theme_classic()+
  theme(legend.position = c(1.3, 0.8), 
        axis.title=element_blank(), 
        axis.line=element_blank(),
        axis.ticks=element_blank(), 
        axis.text=element_blank(),
        plot.background = element_blank(), 
        plot.title=element_text(color="black",size=10,face="plain",hjust=0.5),
        strip.background = element_blank())

```





```{r}
#How does Acro C3A and C3B partition across the reefs? 


```


```{r}
library(wesanderson)
palette = c("#F4B5BD", "#9C964A")

acro_k.pie <- acro_k %>% 
  group_by(Reef, k_id) %>% 
  dplyr::summarise(n = n())

acro_k.pie

ggplot(acro_k.pie, aes(x = "", y = n, fill = factor(k_id))) +
  geom_bar(position="fill", stat="identity") + coord_polar("y")+
  facet_wrap( ~ Reef, ncol = 3) +
  scale_fill_manual(values = palette) +
  theme_classic()+
  theme(legend.position = c(1.3, 0.8), 
        axis.title=element_blank(), 
        axis.line=element_blank(),
        axis.ticks=element_blank(), 
        axis.text=element_blank(),
        plot.background = element_blank(), 
        plot.title=element_text(color="black",size=10,face="plain",hjust=0.5),
        strip.background = element_blank()) 
```

